{
  "version": 3,
  "sources": ["../../src/fragola.ts"],
  "sourcesContent": ["import z from \"zod\";\nimport { Agent, type AgentContext, type CreateAgentOptions } from \"./agent\";\nimport type { maybePromise } from \"./types\";\nimport type { ClientOptions } from \"openai/index.js\";\nimport OpenAI from \"openai/index.js\";\nimport type { Store } from \"./store\";\n\nexport type ToolHandlerReturnTypeNonAsync = any[] | Record<any, any> | Function | number | bigint | boolean | string;\nexport type ToolHandlerReturnType = maybePromise<ToolHandlerReturnTypeNonAsync>;\nexport type AllowedMetaKeys = \"user\" | \"ai\" | \"tool\";\n\n/**\n * Restricts metadata definition to only \"user\", \"ai\", and \"tool\" keys.\n * Any other keys will be omitted from the resulting type.\n */\nexport type DefineMetaData<T extends Partial<Record<AllowedMetaKeys, any>>> = {\n    [K in keyof T as K extends AllowedMetaKeys ? K : never]: T[K]\n};\n\nexport type ChatCompletionUserMessageParam<MetaData extends { user?: any } = {}> = OpenAI.Chat.ChatCompletionUserMessageParam & { meta?: MetaData[\"user\"] };\n\nexport type ChatCompletionAssistantMessageParam<MetaData extends { ai?: any } = {}> = OpenAI.Chat.ChatCompletionAssistantMessageParam & { meta?: MetaData[\"ai\"] };\n\nexport type ChatCompletionToolMessageParam<MetaData extends { tool?: any } = {}> = OpenAI.Chat.ChatCompletionToolMessageParam & { meta?: MetaData[\"tool\"] };\n\nexport type MessageMeta<TMetaData extends DefineMetaData<any>, TKey extends AllowedMetaKeys> = TMetaData extends { [K in TKey]?: any } ? TMetaData[TKey] : never;\n\nexport type ChatCompletionMessageParam<TMetaData extends DefineMetaData<any> = {}> = ChatCompletionUserMessageParam<MessageMeta<TMetaData, \"user\">>\n    | ChatCompletionAssistantMessageParam<MessageMeta<TMetaData, \"ai\">>\n    | ChatCompletionToolMessageParam<MessageMeta<TMetaData, \"tool\">>\n    | OpenAI.Chat.Completions.ChatCompletionDeveloperMessageParam\n    | OpenAI.Chat.Completions.ChatCompletionSystemMessageParam\n    | OpenAI.Chat.Completions.ChatCompletionFunctionMessageParam\n    ;\n\nexport interface Tool<T extends z.ZodType<any, any> = any> {\n    /**\n     * The name of the tool.\n     */\n    name: string;\n    /**\n     * A detailed description of the tool's purpose.\n     */\n    description: string;\n    /**\n     * The function that handles the tool's logic, or the string \"dynamic\" for dynamic handlers.\n     */\n    handler: ((parameters: z.infer<T>, context: AgentContext<any, any>) => ToolHandlerReturnType) | \"dynamic\";\n    /**\n     * The Zod schema that validates the parameters for the tool.\n     */\n    schema?: T;\n}\n\nexport const tool = <T extends z.ZodType<any, any>>(params: Tool<T>) => params;\n\nexport function stripMeta<T extends object>(data: (T & { meta?: any }) | Array<T & { meta?: any }>) {\n    const _strip = (message: T & { meta?: any }) => {\n        const { meta, ...messageWithoutMeta } = message;\n        void meta;\n        return messageWithoutMeta;\n    };\n    if (Array.isArray(data))\n        return data.map(msg => _strip(msg));\n    return _strip(data);\n}\n\nexport const stripConversationMeta = (conversation: ChatCompletionMessageParam[]): OpenAI.ChatCompletionMessageParam[] => stripMeta(conversation) as OpenAI.ChatCompletionMessageParam[];\n\nexport const stripAiMessageMeta = (aiMessage: ChatCompletionAssistantMessageParam): OpenAI.ChatCompletionAssistantMessageParam => stripMeta(aiMessage) as OpenAI.ChatCompletionAssistantMessageParam;\n\nexport const stripUserMessageMeta = (userMessage: ChatCompletionUserMessageParam): OpenAI.ChatCompletionUserMessageParam => stripMeta(userMessage) as OpenAI.ChatCompletionUserMessageParam;\n\nexport const stripToolMessageMeta = (toolMessage: ChatCompletionToolMessageParam): OpenAI.ChatCompletionToolMessageParam => stripMeta(toolMessage) as OpenAI.ChatCompletionToolMessageParam;\n\nexport class Fragola<TGlobalStore = {}> {\n    private openai: OpenAI;\n    constructor(clientOptions?: ClientOptions, private globalStore: Store<TGlobalStore> | undefined = undefined) {\n        this.openai = clientOptions ? new OpenAI(clientOptions) : new OpenAI();\n    }\n\n    agent<TMetaData extends DefineMetaData<any> = {}, TStore = {}>(opts: CreateAgentOptions<TStore>): Agent<TMetaData, TGlobalStore, TStore> {\n        return new Agent<TMetaData, TGlobalStore, TStore>(opts, this.globalStore, this.openai);\n    }\n}"],
  "mappings": "AAAA,MAAc,MACd,OAAS,SAAAA,MAAyD,UAGlE,OAAOC,MAAY,kBAkDZ,MAAMC,EAAuCC,GAAoBA,EAEjE,SAASC,EAA4BC,EAAwD,CAChG,MAAMC,EAAUC,GAAgC,CAC5C,KAAM,CAAE,KAAAC,EAAM,GAAGC,CAAmB,EAAIF,EAExC,OAAOE,CACX,EACA,OAAI,MAAM,QAAQJ,CAAI,EACXA,EAAK,IAAIK,GAAOJ,EAAOI,CAAG,CAAC,EAC/BJ,EAAOD,CAAI,CACtB,CAEO,MAAMM,EAAyBC,GAAoFR,EAAUQ,CAAY,EAEnIC,EAAsBC,GAA+FV,EAAUU,CAAS,EAExIC,EAAwBC,GAAuFZ,EAAUY,CAAW,EAEpIC,EAAwBC,GAAuFd,EAAUc,CAAW,EAE1I,MAAMC,CAA2B,CAEpC,YAAYC,EAAuCC,EAA+C,OAAW,CAA1D,iBAAAA,EAC/C,KAAK,OAASD,EAAgB,IAAInB,EAAOmB,CAAa,EAAI,IAAInB,CAClE,CAHQ,OAKR,MAA+DqB,EAA0E,CACrI,OAAO,IAAItB,EAAuCsB,EAAM,KAAK,YAAa,KAAK,MAAM,CACzF,CACJ",
  "names": ["Agent", "OpenAI", "tool", "params", "stripMeta", "data", "_strip", "message", "meta", "messageWithoutMeta", "msg", "stripConversationMeta", "conversation", "stripAiMessageMeta", "aiMessage", "stripUserMessageMeta", "userMessage", "stripToolMessageMeta", "toolMessage", "Fragola", "clientOptions", "globalStore", "opts"]
}
