import{Store as L}from"./store";import{stripUserMessageMeta as F}from"./fragola";import{zodToJsonSchema as q}from"openai/_vendor/zod-to-json-schema/zodToJsonSchema.mjs";import{streamChunkToMessage as I,isAsyncFunction as m,isSkipEvent as B,skipEventFallback as k}from"./utils";import{BadUsage as S,FragolaError as T,MaxStepHitError as $}from"./exceptions";import z from"openai/index.js";import"./event";import{nanoid as W}from"nanoid";import{EventMap as N}from"./extendedJS/events/EventMap";const et=y=>new L(y),x={maxStep:10,resetStepCountAfterUserMessage:!0,unansweredToolBehaviour:"answer",skipToolString:"Info: this too execution has been canceled. Do not assume it has been processed and inform the user that you are aware of it."},P=Symbol("AgentAccess");class G{constructor(t,e,a,n,s,l,i){this._state=t;this._options=e;this._store=a;this._globalStore=n;this.setInstructionsFn=s;this.setOptionsFn=l;this.stopFn=i}[P]={setState:t=>{this._state=t},setOptions:t=>{this._options=t}};get state(){return this._state}get options(){return this._options}get store(){return this._store}getStore(){return this._store?this._store:void 0}get globalStore(){return this._globalStore}getGlobalStore(){return this._store?this._store:void 0}setInstructions(t){this.setInstructionsFn(t)}setOptions(t){this.setOptionsFn(t)}async stop(){return await this.stopFn()}}class J extends G{constructor(e,a,n,s,l,i,E,p){super(e,a,n,s,l,i,E);this.rawMethods=p}get raw(){return this.rawMethods}}class U{constructor(t,e=void 0,a,n=U.defaultAgentState){this.opts=t;this.globalStore=e;this.state=n;this.context=this.createAgentContext(),this.openai=a,this.toolsToModelSettingsTools(),t.initialConversation!=null&&(this.state.conversation=structuredClone(t.initialConversation)),t.stepOptions?(this.opts.stepOptions={...x,...t.stepOptions},this.validateStepOptions(this.opts.stepOptions)):this.opts.stepOptions=x}static defaultAgentState={conversation:[],stepCount:0,status:"idle"};openai;paramsTools=[];registeredEvents=new N(()=>this.context);abortController=void 0;stopRequested=!1;context;getState(){return this.state}async raw(t){const e=new J(this.state,this.opts,this.opts.store,this.globalStore,a=>{this.opts.instructions=a},a=>{this.opts={...a,name:this.opts.name,store:this.opts.store}},async()=>await this.stop(),{setGenerating:this.setGenerating,setIdle:this.setIdle,setWaiting:this.setWaiting,dispatchState:async a=>{this.updateState(()=>a)}});if(m(t)){const a=await t(this.openai,e);this.updateState(()=>a)}else{const a=t(this.openai,e);this.updateState(()=>a)}return this.state}toolsToModelSettingsTools(){const t=[];this.opts.tools?.forEach(e=>{t.push({type:"function",function:{name:e.name,description:e.description,parameters:e.schema?q(e.schema):void 0}})}),this.paramsTools=t}async appendMessages(t,e=!1,a){await this.updateConversation(n=>e?[...n.slice(0,-1),...t]:[...n,...t],a)}async setIdle(){await this.updateState(t=>({...t,status:"idle"}))}async setGenerating(){await this.updateState(t=>({...t,status:"generating"}))}async setWaiting(){await this.updateState(t=>({...t,status:"waiting"}))}async updateState(t){this.state=t(this.state),this.context[P].setState(this.state),await this.applyEvents("after:stateUpdate",null)}async updateConversation(t,e){await this.updateState(a=>({...a,conversation:t(this.state.conversation)})),await this.applyEvents("after:conversationUpdate",{reason:e})}setOptions(t){if(this.state.status!=="idle")throw new S(`Cannot change options while agent is '${this.state.status}'. Options can only be changed when agent status is 'idle'.`);this.opts={...this.opts,...t},this.context[P].setOptions({...this.context.options,...t})}get options(){return this.opts}stepOptions(){return this.opts.stepOptions}validateStepOptions(t){if(!t)return;const{maxStep:e}=t;if(e!=null&&e<=0)throw new S(`field 'maxStep' of 'StepOptions' cannot be less than or equal to 0. Received '${e}'`)}async step(t){let e;if(t){const{by:n,...s}=t;if(n!=null&&n<=0)throw new S(`field 'by' of 'stepParams' cannot be less than or equal to 0. Received '${n}'`);(!s||Object.keys(s).length!=0)&&(e=s)}e&&this.validateStepOptions(e);const a=e?{...x,...e}:this.stepOptions();return this.state.conversation.length!=0&&await this.recursiveAgent(a,()=>t?.by!=null?this.state.stepCount==this.state.stepCount+t.by:!1).finally(()=>{this.abortController=void 0,this.stopRequested=!1}),this.state}resetStepCount(){this.state.stepCount=0}reset(t={initialConversation:[]}){if(this.state.status!="idle")throw new S(`Cannot reset while agent is '${this.state.status}'. Agent can only be reset when agent status is 'idle'.`);this.updateState(()=>({status:"idle",conversation:t.initialConversation,stepCount:0}))}async stop(){this.stopRequested=!0,this.abortController&&this.abortController.abort()}lastAiMessage(t){for(let e=t.length-1;e>=0;e--){const a=t[e];if(a.role==="assistant")return a}}createAgentContext(){return new G(this.state,this.opts,this.opts.store,this.globalStore,t=>{this.opts.instructions=t},t=>{this.opts={...t,name:this.opts.name,store:this.opts.store}},async()=>await this.stop())}setStepCount(t){this.updateState(e=>({...e,stepCount:t}))}async recursiveAgent(t,e,a=0){if(this.stopRequested)return;if(t.resetStepCountAfterUserMessage&&this.state.conversation.at(-1)?.role=="user"&&this.setStepCount(0),this.state.stepCount==t.maxStep)throw new $("");this.abortController=new AbortController;const n=this.state.conversation.at(-1);let s,l,i=[];if((()=>{if(n?.role=="user")return!0;if(n?.role=="tool"){if(l=this.lastAiMessage(this.state.conversation),!l)throw new T("Invalid conversation, found 'tool' role without previous 'assistant' role.");if(!l.tool_calls)throw new T("Invalid conversation, found 'tool' role but 'tool_calls' is empty in previous 'assistant' role.");return i=l.tool_calls.filter(p=>!this.state.conversation.some(r=>r.role=="tool"&&r.tool_call_id==p.id)),i.length==0}return!1})()){const p=this.registeredEvents.get("modelInvocation"),r=g=>g,d=this.opts.modelSettings,c=async(g,f,h)=>{const o=g||r,v=f||d,C=h?new z(h):this.openai,R=this.opts.useDeveloperRole?"developer":"system",O={...v,messages:[{role:R,content:this.opts.instructions},...this.state.conversation]};this.paramsTools?.length&&(O.tools=this.paramsTools),this.setGenerating();const M=await C.chat.completions.create(O,{signal:this.abortController.signal});if(Symbol.asyncIterator in M){let u={},A=!1;for await(const b of M){if(o.constructor.name=="AsyncFunction"){const w=await o(b,u);u=I(w,u)}else{const w=o(b,u);u=I(w,u)}const D=b.choices[0].finish_reason?"AiMessage":"partialAiMessage",_=await this.registeredEvents.handleAiMessage(u,D=="partialAiMessage");await this.appendMessages([_],A,D),A||this.setStepCount(this.state.stepCount+1),A=!0}this.abortController=void 0,s=u}else this.abortController=void 0,s=M.choices[0].message,await this.appendMessages([s],!1,"AiMessage"),this.setStepCount(this.state.stepCount+1);return s.role=="assistant"&&s.tool_calls&&s.tool_calls.length&&(i=s.tool_calls),s};if(p)for(const g of p){const f=[c,this.context],h=g.callback;h.constructor.name=="AsyncFunction"?s=k(await h(...f),await c()):s=k(h(...f),await c())}else await c()}else n?.role=="assistant"&&n.tool_calls&&n.tool_calls.length&&(i=n.tool_calls);if(i.length>0){await this.setWaiting();for(const p of i){if(this.stopRequested)break;const r=this.opts.tools?.find(o=>o.name==p.function.name);if(!r)throw new T(`Tool ${p.function.name} missing`);let d;if(r.schema&&(d=r.schema.safeParse(JSON.parse(p.function.arguments)),!d.success))throw new T("Tool arguments parsing fail");const c=this.registeredEvents.get("toolCall"),g=await(async()=>{t:{if(!c){if(r.handler=="dynamic")throw new S("Tools with dynamic handlers must have at least 1 'toolCall' event that produces a result.");break t}for(let o=0;o<c.length;o++){const v=c[o],C=m(v.callback)?await v.callback(d?.data,r,this.context):v.callback(d?.data,r,this.context);if(!B(C))return C}if(r.handler=="dynamic")throw new S("Tools with dynamic handlers must have at least 1 'toolCall' event that produces a result. (one or more events were found but returned 'skip')")}return m(r.handler)?await r.handler(d?.data,this.context):r.handler(d?.data,this.context)})(),h={role:"tool",content:(o=>{switch(typeof o){case"string":return o;case"function":return o.toString();case"undefined":case"number":case"boolean":case"bigint":return String(o);default:return JSON.stringify(o)}})(g),tool_call_id:p.id};await this.updateConversation(o=>[...o,h],"toolCall")}if(await this.setIdle(),!e())return await this.recursiveAgent(t,e,a+1)}await this.setIdle()}async userMessage(t){const{step:e,...a}=t;let n;return this.registeredEvents.handleUserMessage?n=await this.registeredEvents.handleUserMessage(a):n=a,await this.updateConversation(s=>[...s,F({role:"user",...n})],"userMessage"),await this.step(t.step)}async applyEvents(t,e){const a=this.registeredEvents.get(t);if(a)for(let n=0;n<a.length;n++){const s=a[n].callback,l=[this.createAgentContext()];switch(t){case"after:stateUpdate":{const i=l;return m(s)?await s(...i):s(...i)}case"after:conversationUpdate":{const i=[e.reason,...l];return m(s)?await s(...i):s(...i)}default:throw new T(`Internal error: event with name '${t}' is unknown`)}}}on(t,e){const a=this.registeredEvents.get(t)||[],n=W();return a.push({id:n,callback:e}),this.registeredEvents.set(t,a),()=>{let s=this.registeredEvents.get(t);s&&(s=s.filter(l=>l.id!=n),s.length?this.registeredEvents.set(t,s):this.registeredEvents.delete(t))}}onToolCall(t){return this.on("toolCall",t)}onAfterConversationUpdate(t){return this.on("after:conversationUpdate",t)}onAiMessage(t){return this.on("aiMessage",t)}onUserMessage(t){return this.on("userMessage",t)}onModelInvocation(t){return this.on("modelInvocation",t)}onAfterStateUpdate(t){return this.on("after:stateUpdate",t)}}export{U as Agent,G as AgentContext,J as AgentRawContext,et as createStore,x as defaultStepOptions};
//# sourceMappingURL=agent.js.map
