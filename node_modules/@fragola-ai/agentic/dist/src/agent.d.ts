import { Store } from "./store";
import { type ChatCompletionMessageParam, type DefineMetaData, type Tool } from "./fragola";
import type { ChatCompletionCreateParamsBase } from "openai/resources/chat/completions.js";
import type { maybePromise, Prettify, StoreLike } from "./types";
import OpenAI from "openai/index.js";
import { type AgentEventId } from "./event";
import type { EventToolCall, EventUserMessage, EventModelInvocation, EventAiMessage } from "./eventDefault";
import type { EventAfterConversationUpdate, AfterStateUpdateCallback } from "./eventAfter";
import { type eventIdToCallback } from "./extendedJS/events/EventMap";
export declare const createStore: <T extends StoreLike<any>>(data: StoreLike<T>) => Store<T>;
export type AgentState<TMetaData extends DefineMetaData<any> = {}> = {
    conversation: ChatCompletionMessageParam<TMetaData>[];
    stepCount: number;
    status: "idle" | "generating" | "waiting";
};
/**
 * Options for controlling the agent's step execution behavior.
 *
 * @see {@link defaultStepOptions} for default values.
 */
export type StepOptions = Partial<{
    /** The maximum number of steps to execute in one call (default: 10). */
    maxStep: number;
    /** Wether or not to reset agent state `stepCount` after each user messages. `true` is recommanded for conversational agents.*/
    resetStepCountAfterUserMessage: boolean;
    unansweredToolBehaviour: "answer" | "skip";
    skipToolString: string;
}>;
/**
 * @typescript The default values for {@link StepOptions}.
 *
 * @property maxStep - Default: 10. The maximum number of steps to execute in one call.
 * @property unansweredToolBehaviour - Default: "answer". Determines how to handle unanswered tool calls.
 * @property skipToolString - Default: "(generation has been canceled, you may ignore this tool output)". The string to use when skipping a tool call.
 */
export declare const defaultStepOptions: StepOptions;
/**
 * Options for configuring the agent context.
 */
export interface AgentContexOptions {
    /** Optional settings for each step in the agent's process. */
    stepOptions?: StepOptions;
    /** The name assigned to the agent. */
    name: string;
    /** Whether to use the developer role for the agent (optional). */
    useDeveloperRole?: boolean;
    /** Instructions or guidelines for the agent's behavior. */
    instructions: string;
    /** Optional array of tools available to the agent. */
    tools?: Tool<any>[];
    /** Model-specific settings excluding messages and tools. */
    modelSettings: Prettify<Omit<ChatCompletionCreateParamsBase, "messages" | "tools">>;
}
export type SetOptionsParams = Omit<AgentContexOptions, "name" | "initialConversation">;
export type CreateAgentOptions<TStore extends StoreLike<any> = {}> = {
    store?: Store<TStore>;
    /** Optional initial conversation history for the agent. */
    initialConversation?: OpenAI.ChatCompletionMessageParam[];
} & Prettify<AgentContexOptions>;
export type ResetParams = Prettify<Pick<Required<CreateAgentOptions>, "initialConversation">>;
export type AgentRaw<TMetaData extends DefineMetaData<any>, TGlobalStore, TStore> = (openai: OpenAI, context: AgentRawContext<TMetaData, TGlobalStore, TStore>) => maybePromise<AgentState<TMetaData>>;
declare const AGENT_FRIEND: unique symbol;
/**
 * Context of the agent which triggered the event or tool.
 */
export declare class AgentContext<TMetaData extends DefineMetaData<any> = {}, TGlobalStore extends StoreLike<any> = {}, TStore extends StoreLike<any> = {}> {
    private _state;
    private _options;
    private _store;
    private _globalStore;
    private setInstructionsFn;
    private setOptionsFn;
    private stopFn;
    constructor(_state: AgentState<TMetaData>, _options: AgentContexOptions, _store: Store<TStore> | undefined, _globalStore: Store<TGlobalStore> | undefined, setInstructionsFn: (instructions: string) => void, setOptionsFn: (options: SetOptionsParams) => void, stopFn: () => Promise<void>);
    [AGENT_FRIEND]: {
        setState: (newState: AgentState) => void;
        setOptions: (newOptions: AgentContexOptions) => void;
    };
    /** The current state of the agent. */
    get state(): AgentState<TMetaData>;
    /** The configuration options for the agent context. */
    get options(): AgentContexOptions;
    /** Acess the agent's local store. */
    get store(): Store<TStore> | undefined;
    /** Returns the agent's local store casted as T. Recommanded when accessing the store from a tool */
    getStore<T extends StoreLike<any>>(): Store<T> | undefined;
    /** Access the global store shared across agents of the same Fragola instance. */
    get globalStore(): Store<TGlobalStore> | undefined;
    /** Returns the global store casted as T. Recommanded when accessing the global store from a tool */
    getGlobalStore<T extends StoreLike<any>>(): Store<T> | undefined;
    /**
     * Sets the current instructions for the agent.
     * @param instructions - The new instructions as a string.
     */
    setInstructions(instructions: string): void;
    /**
     * Updates the agent's options.
     * **note**: the `name` property is ommited
     * @param options - The new options to set, as a SetOptionsParams object.
     */
    setOptions(options: SetOptionsParams): void;
    stop(): Promise<void>;
}
export interface agentRawMethods {
    setIdle: () => Promise<void>;
    setWaiting: () => Promise<void>;
    setGenerating: () => Promise<void>;
    dispatchState: (state: AgentState<any>) => Promise<void>;
}
export declare class AgentRawContext<TMetaData extends DefineMetaData<any> = {}, TGlobalStore extends StoreLike<any> = {}, TStore extends StoreLike<any> = {}> extends AgentContext<TMetaData, TGlobalStore, TStore> {
    private rawMethods;
    constructor(_state: AgentState<TMetaData>, _options: AgentContexOptions, _store: Store<TStore> | undefined, _globalStore: Store<TGlobalStore> | undefined, setInstructionsFn: (instructions: string) => void, setOptionsFn: (options: SetOptionsParams) => void, stopFn: () => Promise<void>, rawMethods: agentRawMethods);
    get raw(): agentRawMethods;
}
type StepBy = Partial<{
    /** To execute only up to N steps even if `maxStep` is not hit*/
    by: number;
}>;
export type StepParams = StepBy & StepOptions;
export type UserMessageQuery = Prettify<Omit<OpenAI.Chat.ChatCompletionUserMessageParam, "role">> & {
    step?: StepParams;
};
export declare class Agent<TMetaData extends DefineMetaData<any> = {}, TGlobalStore extends StoreLike<any> = {}, TStore extends StoreLike<any> = {}> {
    private opts;
    private globalStore;
    private state;
    static defaultAgentState: AgentState;
    private openai;
    private paramsTools;
    private registeredEvents;
    private abortController;
    private stopRequested;
    private context;
    constructor(opts: CreateAgentOptions<TStore>, globalStore: Store<TGlobalStore> | undefined, openai: OpenAI, state?: AgentState<TMetaData>);
    getState(): AgentState<TMetaData>;
    raw(callback: AgentRaw<TMetaData, TGlobalStore, TStore>): Promise<AgentState<TMetaData>>;
    private toolsToModelSettingsTools;
    private appendMessages;
    private setIdle;
    private setGenerating;
    private setWaiting;
    private updateState;
    private updateConversation;
    /**
     * Updates the agent's options.
     * **Note**: Can only be called when agent status is "idle".
     * The `name` and `initialConversation` properties are omitted.
     *
     * @param options - The new options to set, as a SetOptionsParams object.
     * @throws {BadUsage} When called while agent is not idle (generating or waiting).
     */
    setOptions(options: SetOptionsParams): void;
    get options(): CreateAgentOptions<TStore>;
    private stepOptions;
    private validateStepOptions;
    step(stepParams?: StepParams): Promise<AgentState<TMetaData>>;
    resetStepCount(): void;
    reset(params?: ResetParams): void;
    /**
     * Stops the current agent execution.
     * This will abort any ongoing API calls and prevent further tool execution.
     */
    stop(): Promise<void>;
    private lastAiMessage;
    private createAgentContext;
    private setStepCount;
    private recursiveAgent;
    userMessage(query: UserMessageQuery): Promise<AgentState>;
    private applyEvents;
    /**
     * Register a handler for a given event id.
     * Returns an unsubscribe function that removes the registered handler.
     *
     * @example
     * // listen to userMessage events
     * const off = agent.on('userMessage', (message, context) => {
     *   // inspect or transform the message
     *   return { ...message, content: message.content.trim() };
     * });
     * // later
     * off();
     */
    on<TEventId extends AgentEventId>(eventId: TEventId, callback: eventIdToCallback<TEventId, TMetaData, TGlobalStore, TStore>): () => void;
    /**
     * Register a tool call event handler.
     *
     * This handler is invoked when the agent needs to execute a tool. Handlers may return a value
     * that will be used as the tool result.
     *
     * @example
     * // simple tool handler that returns an object as result
     * agent.onToolCall(async (params, tool, context) => {
     *   // dynamic tools do not have a handler function, so we skip them
     *   if (params.handler == "dynamic") return skip();
     *   // do something with params and tool
     *   try {
     *      const result = await tool.handler(params);
     *      return { sucess: true, result }
     * } catch(e) {
     *      if (e extends Error)
     *      return { error: e.message }
     * }
     * });
     */
    onToolCall<TParams = Record<any, any>>(callback: EventToolCall<TParams, TMetaData, TGlobalStore, TStore>): () => void;
    /**
     * Register a handler that runs after the conversation is updated.
     *
     * After-event handlers do not return a value. Use these to persist state, emit metrics or side-effects.
     *
     * @example
     * agent.onAfterConversationUpdate((reason, context) => {
     *   // persist conversation to a DB or telemetry
     *   console.log('conversation updated because of', reason);
     *   context.getStore()?.value.lastSaved = Date.now();
     * });
     */
    onAfterConversationUpdate(callback: EventAfterConversationUpdate<TMetaData, TGlobalStore, TStore>): () => void;
    /**
     * Register an AI message event handler.
     *
     * Called when an assistant message is generated or streaming. Handlers may return a modified
     * message which will replace the message in the conversation.
     *
     * @example
     * agent.onAiMessage((message, isPartial, context) => {
     *   if (!isPartial && message.content.includes('debug')) {
     *     // modify final assistant message
     *      message.content += '(edited)';
     *   }
     *   return message;
     * });
     */
    onAiMessage(callback: EventAiMessage<TMetaData, TGlobalStore, TStore>): () => void;
    /**
     * Register a user message event handler.
     *
     * Called when a user message is appended to the conversation. Handlers may return a modified
     * user message which will be used instead of the original.
     *
     * @example
     * agent.onUserMessage((message, context) => {
     *   // enrich user message with metadata
     *   return { ...message, content: message.content.trim() };
     * });
     */
    onUserMessage(callback: EventUserMessage<TMetaData, TGlobalStore, TStore>): () => void;
    /**
     * Register a model invocation event handler.
     *
     * This handler wraps the model call. It receives a `callAPI` function to perform the request and
     * can return a modified assistant message. Handlers can also provide a `processChunk` function to
     * edit streaming chunks before they are applied to the partial assistant message.
     *
     * @example
     * // modify streaming chunks before they are applied
     * agent.onModelInvocation(async (callAPI, context) => {
     *   const processChunk: CallAPIProcessChuck = (chunk, partial) => {
     *     // e.g. redact sensitive tokens or append extra tokens
     *     chunck.choices[0].delta.content = '(modified)';
     *     // perform modifications on `modified` here
     *     return chunck;
     *   };
     *   // pass the processor to callAPI; it returns the final assistant message
     *   const aiMsg = await callAPI(processChunk);
     *   // post-process the final assistant message if needed
     *   return { ...aiMsg, content: aiMsg.content + '\n\n(checked)' };
     * });
     */
    onModelInvocation(callback: EventModelInvocation<TMetaData, TGlobalStore, TStore>): () => void;
    /**
     * Register a handler that runs after the agent state is updated.
     *
     * After-state-update handlers do not return a value. Use these for side-effects such as metrics
     * or asynchronous persistence.
     *
     * @example
     * agent.onAfterStateUpdate((context) => {
     *   // e.g. emit metrics about step count
     *   console.log('stepCount', context.state.stepCount);
     * });
     */
    onAfterStateUpdate(callback: AfterStateUpdateCallback<TMetaData, TGlobalStore, TStore>): () => void;
}
export type AgentAny = Agent<any, any, any>;
export {};
