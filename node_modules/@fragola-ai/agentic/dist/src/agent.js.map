{
  "version": 3,
  "sources": ["../../src/agent.ts"],
  "sourcesContent": ["import { Store } from \"./store\"\nimport { stripUserMessageMeta, type ChatCompletionMessageParam, type ChatCompletionUserMessageParam, type DefineMetaData, type Tool } from \"./fragola\"\nimport type { ChatCompletionCreateParamsBase } from \"openai/resources/chat/completions.js\"\nimport { zodToJsonSchema } from \"openai/_vendor/zod-to-json-schema/zodToJsonSchema.mjs\"\nimport { streamChunkToMessage, isAsyncFunction, isSkipEvent, skipEventFallback } from \"./utils\"\nimport { BadUsage, FragolaError, MaxStepHitError } from \"./exceptions\"\nimport type z from \"zod\"\nimport type { maybePromise, Prettify, StoreLike } from \"./types\"\nimport OpenAI from \"openai/index.js\"\nimport { type AgentEventId, type EventDefaultCallback } from \"./event\"\nimport type { CallAPI, CallAPIProcessChuck, EventToolCall, EventUserMessage, EventModelInvocation, EventAiMessage } from \"./eventDefault\";\nimport { nanoid } from \"nanoid\"\nimport type { EventAfterConversationUpdate, AfterStateUpdateCallback, conversationUpdateReason } from \"./eventAfter\"\nimport { type registeredEvent, type eventIdToCallback, EventMap } from \"./extendedJS/events/EventMap\"\n\nexport const createStore = <T extends StoreLike<any>>(data: StoreLike<T>) => new Store(data);\n\nexport type AgentState<TMetaData extends DefineMetaData<any> = {}> = {\n    conversation: ChatCompletionMessageParam<TMetaData>[],\n    stepCount: number,\n    status: \"idle\" | \"generating\" | \"waiting\",\n}\n\n/**\n * Options for controlling the agent's step execution behavior.\n *\n * @see {@link defaultStepOptions} for default values.\n */\nexport type StepOptions = Partial<{\n    /** The maximum number of steps to execute in one call (default: 10). */\n    maxStep: number,\n    /** Wether or not to reset agent state `stepCount` after each user messages. `true` is recommanded for conversational agents.*/\n    resetStepCountAfterUserMessage: boolean,\n\n    //TODO: unanswered tool behaviour fields\n    // /** Determines how to handle unanswered tool calls: `answer` to process them, `skip` to ignore (default: \"answer\"). */\n    unansweredToolBehaviour: \"answer\" | \"skip\",\n    // /** The string to use when skipping a tool call (default: \"(generation has been canceled, you may ignore this tool output)\"). */\n    skipToolString: string\n}>;\n\n/**\n * @typescript The default values for {@link StepOptions}.\n *\n * @property maxStep - Default: 10. The maximum number of steps to execute in one call.\n * @property unansweredToolBehaviour - Default: \"answer\". Determines how to handle unanswered tool calls.\n * @property skipToolString - Default: \"(generation has been canceled, you may ignore this tool output)\". The string to use when skipping a tool call.\n */\nexport const defaultStepOptions: StepOptions = {\n    maxStep: 10,\n    resetStepCountAfterUserMessage: true,\n    unansweredToolBehaviour: \"answer\",\n    skipToolString: \"Info: this too execution has been canceled. Do not assume it has been processed and inform the user that you are aware of it.\"\n}\n\n/**\n * Options for configuring the agent context.\n */\nexport interface AgentContexOptions {\n    /** Optional settings for each step in the agent's process. */\n    stepOptions?: StepOptions,\n    /** The name assigned to the agent. */\n    name: string,\n    /** Whether to use the developer role for the agent (optional). */\n    useDeveloperRole?: boolean,\n    /** Instructions or guidelines for the agent's behavior. */\n    instructions: string,\n    /** Optional array of tools available to the agent. */\n    tools?: Tool<any>[],\n    /** Model-specific settings excluding messages and tools. */\n    modelSettings: Prettify<Omit<ChatCompletionCreateParamsBase, \"messages\" | \"tools\">>,\n} //TODO: better comment for stepOptions with explaination for each fields\n\nexport type SetOptionsParams = Omit<AgentContexOptions, \"name\" | \"initialConversation\">;\n\nexport type CreateAgentOptions<TStore extends StoreLike<any> = {}> = {\n    store?: Store<TStore>,\n    /** Optional initial conversation history for the agent. */\n    initialConversation?: OpenAI.ChatCompletionMessageParam[],\n} & Prettify<AgentContexOptions>;\n\nexport type ResetParams = Prettify<Pick<Required<CreateAgentOptions>, \"initialConversation\">>;\n\nexport type AgentRaw<TMetaData extends DefineMetaData<any>, TGlobalStore, TStore> = (openai: OpenAI, context: AgentRawContext<TMetaData, TGlobalStore, TStore>) => maybePromise<AgentState<TMetaData>>;\n\nconst AGENT_FRIEND = Symbol('AgentAccess');\n\n/**\n * Context of the agent which triggered the event or tool.\n */\nexport class AgentContext<TMetaData extends DefineMetaData<any> = {}, TGlobalStore extends StoreLike<any> = {}, TStore extends StoreLike<any> = {}> {\n    constructor(\n        private _state: AgentState<TMetaData>,\n        private _options: AgentContexOptions,\n        private _store: Store<TStore> | undefined,\n        private _globalStore: Store<TGlobalStore> | undefined,\n        private setInstructionsFn: (instructions: string) => void,\n        private setOptionsFn: (options: SetOptionsParams) => void,\n        private stopFn: () => Promise<void>\n    ) { }\n\n    [AGENT_FRIEND] = {\n        setState: (newState: AgentState) => {\n            this._state = newState;\n        },\n        setOptions: (newOptions: AgentContexOptions) => {\n            this._options = newOptions;\n        },\n    };\n\n    /** The current state of the agent. */\n    get state() {\n        return this._state;\n    }\n\n    /** The configuration options for the agent context. */\n    get options() {\n        return this._options;\n    }\n\n    /** Acess the agent's local store. */\n    get store() {\n        return this._store as Store<TStore> | undefined;\n    }\n\n    /** Returns the agent's local store casted as T. Recommanded when accessing the store from a tool */\n    getStore<T extends StoreLike<any>>(): Store<T> | undefined { return this._store ? this._store as unknown as Store<T> : undefined }\n\n    /** Access the global store shared across agents of the same Fragola instance. */\n    get globalStore() {\n        return this._globalStore as Store<TGlobalStore> | undefined;\n    }\n\n    /** Returns the global store casted as T. Recommanded when accessing the global store from a tool */\n    getGlobalStore<T extends StoreLike<any>>(): Store<T> | undefined { return this._store ? this._store as unknown as Store<T> : undefined }\n\n    /**\n     * Sets the current instructions for the agent.\n     * @param instructions - The new instructions as a string.\n     */\n    setInstructions(instructions: string) {\n        this.setInstructionsFn(instructions);\n    }\n\n    /**\n     * Updates the agent's options.\n     * **note**: the `name` property is ommited\n     * @param options - The new options to set, as a SetOptionsParams object.\n     */\n    setOptions(options: SetOptionsParams) {\n        this.setOptionsFn(options);\n    }\n\n    async stop() {\n        return await this.stopFn();\n    }\n}\n\nexport interface agentRawMethods {\n    setIdle: () => Promise<void>,\n    setWaiting: () => Promise<void>,\n    setGenerating: () => Promise<void>,\n    dispatchState: (state: AgentState<any>) => Promise<void>,\n}\n\nexport class AgentRawContext<TMetaData extends DefineMetaData<any> = {}, TGlobalStore extends StoreLike<any> = {}, TStore extends StoreLike<any> = {}> extends AgentContext<TMetaData, TGlobalStore, TStore> {\n    constructor(\n        _state: AgentState<TMetaData>,\n        _options: AgentContexOptions,\n        _store: Store<TStore> | undefined,\n        _globalStore: Store<TGlobalStore> | undefined,\n        setInstructionsFn: (instructions: string) => void,\n        setOptionsFn: (options: SetOptionsParams) => void,\n        stopFn: () => Promise<void>,\n        private rawMethods: agentRawMethods\n    ) {\n        super(_state, _options, _store, _globalStore, setInstructionsFn, setOptionsFn, stopFn);\n    }\n\n    get raw() {\n        return this.rawMethods;\n    }\n}\n\ntype StepBy = Partial<{\n    /** To execute only up to N steps even if `maxStep` is not hit*/\n    by: number,\n}>;\n\nexport type StepParams = StepBy & StepOptions;\n\nexport type UserMessageQuery = Prettify<Omit<OpenAI.Chat.ChatCompletionUserMessageParam, \"role\">> & { step?: StepParams };\n\ntype ConversationUpdateParams = {\n    reason: conversationUpdateReason\n}\n\ntype ApplyAfterConversationUpdateParams = ConversationUpdateParams;\n\ntype applyEventParams<K extends AgentEventId> =\n    K extends \"after:conversationUpdate\" ? ApplyAfterConversationUpdateParams :\n    K extends \"conversationUpdate\" ? ConversationUpdateParams :\n    never;\n\nexport class Agent<TMetaData extends DefineMetaData<any> = {}, TGlobalStore extends StoreLike<any> = {}, TStore extends StoreLike<any> = {}> {\n    public static defaultAgentState: AgentState = {\n        conversation: [],\n        stepCount: 0,\n        status: \"idle\"\n    }\n\n    private openai: OpenAI;\n    private paramsTools: ChatCompletionCreateParamsBase[\"tools\"] = [];\n    private registeredEvents: EventMap<AgentEventId, registeredEvent<AgentEventId, TMetaData, TGlobalStore, TStore>[], TMetaData, TGlobalStore, TStore> = new EventMap(() => this.context)\n    // private registeredEvents: Map<AgentEventId, registeredEvent<AgentEventId, TMetaData, TGlobalStore, TStore>[]> = new Map();\n    private abortController: AbortController | undefined = undefined;\n    private stopRequested: boolean = false;\n    private context: AgentContext<TMetaData, TGlobalStore, TStore>;\n\n    constructor(\n        private opts: CreateAgentOptions<TStore>,\n        private globalStore: Store<TGlobalStore> | undefined = undefined,\n        openai: OpenAI,\n        private state = Agent.defaultAgentState as AgentState<TMetaData>) {\n        this.context = this.createAgentContext();\n        this.openai = openai;\n        this.toolsToModelSettingsTools();\n        if (opts.initialConversation != undefined)\n            this.state.conversation = structuredClone(opts.initialConversation);\n        if (!opts.stepOptions)\n            this.opts[\"stepOptions\"] = defaultStepOptions;\n        else {\n            this.opts[\"stepOptions\"] = {\n                ...defaultStepOptions,\n                ...opts.stepOptions\n            }\n            this.validateStepOptions(this.opts.stepOptions);\n        }\n    }\n    getState() { return this.state };\n\n    async raw(callback: AgentRaw<TMetaData, TGlobalStore, TStore>) {\n        const rawContext = new AgentRawContext(this.state,\n            this.opts,\n            this.opts.store as Store<TStore> | undefined,\n            this.globalStore as Store<TGlobalStore> | undefined,\n            (instructions) => {\n                this.opts[\"instructions\"] = instructions;\n            },\n            (options) => {\n                this.opts = { ...options, name: this.opts.name, store: this.opts.store }\n            },\n            async () => await this.stop(), {\n            setGenerating: this.setGenerating,\n            setIdle: this.setIdle,\n            setWaiting: this.setWaiting,\n            dispatchState: async (state: AgentState<any>) => {\n                this.updateState(() => state)\n            }\n        });\n\n        if (isAsyncFunction(callback)) {\n            const newState = await callback(this.openai, rawContext);\n            this.updateState(() => newState);\n        } else {\n            const newState = callback(this.openai, rawContext) as Awaited<ReturnType<typeof callback>>;\n            this.updateState(() => newState);\n        }\n        return this.state\n    }\n\n    private toolsToModelSettingsTools() {\n        const result: ChatCompletionCreateParamsBase[\"tools\"] = [];\n        this.opts.tools?.forEach(tool => {\n            result.push({\n                type: \"function\",\n                function: {\n                    name: tool.name,\n                    description: tool.description,\n                    parameters: tool.schema ? zodToJsonSchema(tool.schema) : undefined\n                }\n\n            })\n        });\n        this.paramsTools = result;\n    }\n\n    private async appendMessages(messages: OpenAI.ChatCompletionMessageParam[], replaceLast: boolean = false, reason: conversationUpdateReason) {\n        await this.updateConversation((prev) => {\n            if (replaceLast)\n                return [...prev.slice(0, -1), ...messages];\n            return [...prev, ...messages]\n        }, reason);\n    }\n\n    private async setIdle() { await this.updateState(prev => ({ ...prev, status: \"idle\" })) }\n    private async setGenerating() { await this.updateState(prev => ({ ...prev, status: \"generating\" })) }\n    private async setWaiting() { await this.updateState(prev => ({ ...prev, status: \"waiting\" })) }\n\n\n    private async updateState(callback: (prev: typeof this.state) => typeof this.state) {\n        this.state = callback(this.state);\n        this.context[AGENT_FRIEND].setState(this.state);\n        await this.applyEvents(\"after:stateUpdate\", null);\n    }\n\n    private async updateConversation(callback: (prev: AgentState<TMetaData>[\"conversation\"]) => AgentState<TMetaData>[\"conversation\"], reason: conversationUpdateReason) {\n        await this.updateState((prev) => ({ ...prev, conversation: callback(this.state.conversation) }));\n        await this.applyEvents(\"after:conversationUpdate\", { reason });\n    }\n\n    /**\n     * Updates the agent's options.\n     * **Note**: Can only be called when agent status is \"idle\". \n     * The `name` and `initialConversation` properties are omitted.\n     * \n     * @param options - The new options to set, as a SetOptionsParams object.\n     * @throws {BadUsage} When called while agent is not idle (generating or waiting).\n     */\n    setOptions(options: SetOptionsParams) {\n        if (this.state.status !== \"idle\") {\n            throw new BadUsage(\n                `Cannot change options while agent is '${this.state.status}'. ` +\n                `Options can only be changed when agent status is 'idle'.`\n            );\n        }\n        this.opts = { ...this.opts, ...options };\n        this.context[AGENT_FRIEND].setOptions({ ...this.context.options, ...options });\n    }\n\n    get options() { return this.opts }\n\n    private stepOptions() { return this.opts.stepOptions as Required<StepOptions> }\n\n    private validateStepOptions(stepOptions: StepOptions | undefined) {\n        if (!stepOptions)\n            return;\n        const { maxStep } = stepOptions;\n        if (maxStep != undefined) {\n            if (maxStep <= 0)\n                throw new BadUsage(`field 'maxStep' of 'StepOptions' cannot be less than or equal to 0. Received '${maxStep}'`)\n        }\n    }\n\n    async step(stepParams?: StepParams) {\n        let overrideStepOptions: StepOptions | undefined = undefined;\n        if (stepParams) {\n            const { by, ...rest } = stepParams;\n            if (by != undefined && by <= 0)\n                throw new BadUsage(`field 'by' of 'stepParams' cannot be less than or equal to 0. Received '${by}'`);\n            if (!rest || Object.keys(rest).length != 0)\n                overrideStepOptions = rest;\n        }\n        if (overrideStepOptions)\n            this.validateStepOptions(overrideStepOptions);\n        const stepOptions: Required<StepOptions> = overrideStepOptions ? { ...defaultStepOptions, ...overrideStepOptions } as Required<StepOptions> : this.stepOptions();\n        if (this.state.conversation.length != 0)\n            await this.recursiveAgent(stepOptions, () => {\n                if (stepParams?.by != undefined)\n                    return this.state.stepCount == (this.state.stepCount + stepParams.by);\n                return false;\n            }).finally(() => {\n                this.abortController = undefined;\n                this.stopRequested = false;\n            });\n        return this.state;\n    }\n\n    resetStepCount() {\n        this.state.stepCount = 0;\n    }\n\n    reset(params: ResetParams = { initialConversation: [] }) {\n        if (this.state.status != \"idle\") {\n            throw new BadUsage(\n                `Cannot reset while agent is '${this.state.status}'. ` +\n                `Agent can only be reset when agent status is 'idle'.`\n            );\n        }\n        this.updateState(() => ({\n            status: \"idle\",\n            conversation: params.initialConversation,\n            stepCount: 0\n        }));\n    }\n\n    /**\n     * Stops the current agent execution.\n     * This will abort any ongoing API calls and prevent further tool execution.\n     */\n    async stop() {\n        this.stopRequested = true;\n        if (this.abortController) {\n            this.abortController.abort();\n        }\n    }\n\n    private lastAiMessage(conversation: OpenAI.ChatCompletionMessageParam[]): OpenAI.ChatCompletionAssistantMessageParam | undefined {\n        for (let i = conversation.length - 1; i >= 0; i--) {\n            const msg = conversation[i];\n            if (msg.role === \"assistant\") {\n                return msg;\n            }\n        }\n        return undefined;\n    }\n\n    private createAgentContext<TM extends DefineMetaData<any> = TMetaData, TGS extends StoreLike<any> = TGlobalStore, TS extends StoreLike<any> = TStore>(): AgentContext<TM, TGS, TS> {\n        return new AgentContext<TM, TGS, TS>(\n            this.state,\n            this.opts,\n            this.opts.store as Store<TS> | undefined,\n            this.globalStore as Store<TGS> | undefined,\n            (instructions) => {\n                this.opts[\"instructions\"] = instructions;\n            },\n            (options) => {\n                this.opts = { ...options, name: this.opts.name, store: this.opts.store }\n            },\n            async () => await this.stop()\n        );\n    }\n\n    private setStepCount(value: number) {\n        this.updateState((prev) => {\n            return {\n                ...prev,\n                stepCount: value\n            }\n        });\n    }\n\n    private async recursiveAgent(stepOptions: Required<StepOptions>, stop: () => boolean, iter = 0): Promise<void> {\n        // Check if stop was requested\n        if (this.stopRequested) {\n            return;\n        }\n\n        if (stepOptions.resetStepCountAfterUserMessage) {\n            if (this.state.conversation.at(-1)?.role == \"user\")\n                this.setStepCount(0);\n        }\n        if (this.state.stepCount == stepOptions.maxStep)\n            throw new MaxStepHitError(``);\n\n        this.abortController = new AbortController();\n\n        const lastMessage: OpenAI.ChatCompletionMessageParam | undefined = this.state.conversation.at(-1);\n        let aiMessage: OpenAI.ChatCompletionAssistantMessageParam;\n        let lastAiMessage: OpenAI.ChatCompletionAssistantMessageParam | undefined = undefined;\n        let toolCalls: OpenAI.Chat.Completions.ChatCompletionMessageToolCall[] = [];\n\n        const shouldGenerate: boolean = (() => {\n            if (lastMessage?.role == \"user\")\n                return true;\n            if (lastMessage?.role == \"tool\") {\n                lastAiMessage = this.lastAiMessage(this.state.conversation);\n                if (!lastAiMessage)\n                    throw new FragolaError(\"Invalid conversation, found 'tool' role without previous 'assistant' role.\");\n                if (!lastAiMessage.tool_calls)\n                    throw new FragolaError(\"Invalid conversation, found 'tool' role but 'tool_calls' is empty in previous 'assistant' role.\");\n\n                // Some tool calls may be already answered, we filter them out\n                toolCalls = lastAiMessage.tool_calls.filter(toolCall => {\n                    return !this.state.conversation.some(message => message.role == \"tool\" && message.tool_call_id == toolCall.id)\n                });\n                // Generation can happen only if all tool_calls have been answered, if not the case, tool calls will be answered and the generation can happen in the next recursive turn\n                return toolCalls.length == 0;\n            }\n            return false;\n        })();\n\n        if (shouldGenerate) {\n            const EmodelInvocation = this.registeredEvents.get(\"modelInvocation\");\n            const defaultProcessChunck: CallAPIProcessChuck = (chunck) => chunck;\n            const defaultModelSettings: CreateAgentOptions<any>[\"modelSettings\"] = this.opts.modelSettings;\n\n            const callAPI: CallAPI = async (processChunck, modelSettings, clientOpts) => {\n                const _processChunck = processChunck || defaultProcessChunck;\n                const _modelSettings = modelSettings || defaultModelSettings;\n                const openai = clientOpts ? new OpenAI(clientOpts) : this.openai;\n\n                const role: ChatCompletionCreateParamsBase[\"messages\"][0][\"role\"] = this.opts.useDeveloperRole ? \"developer\" : \"system\";\n                const requestBody: ChatCompletionCreateParamsBase = {\n                    ..._modelSettings,\n                    messages: [{ role, content: this.opts.instructions }, ...this.state.conversation]\n                };\n                if (this.paramsTools?.length)\n                    requestBody[\"tools\"] = this.paramsTools;\n\n                this.setGenerating();\n                const response = await openai.chat.completions.create(requestBody, { signal: this.abortController!.signal });\n\n                // Handle streaming vs non-streaming\n                if (Symbol.asyncIterator in response) {\n                    let partialMessage: Partial<OpenAI.Chat.ChatCompletionMessageParam> = {};\n                    let replaceLast = false;\n\n                    for await (const chunck of response) {\n                        if (_processChunck.constructor.name == \"AsyncFunction\") {\n                            const _chunck = await _processChunck(chunck, partialMessage as typeof aiMessage);\n                            partialMessage = streamChunkToMessage(_chunck, partialMessage);\n                        } else {\n                            const _chunck = _processChunck(chunck, partialMessage as typeof aiMessage);\n                            partialMessage = streamChunkToMessage(_chunck as OpenAI.ChatCompletionChunk, partialMessage);\n                        }\n                        const updateReason: conversationUpdateReason = !chunck.choices[0].finish_reason ? \"partialAiMessage\" : \"AiMessage\";\n                        const partialMessageFinal = await this.registeredEvents.handleAiMessage(partialMessage as typeof aiMessage, updateReason == \"partialAiMessage\");\n                        await this.appendMessages([partialMessageFinal as OpenAI.Chat.ChatCompletionMessageParam], replaceLast, updateReason);\n                        if (!replaceLast) this.setStepCount(this.state.stepCount + 1);\n                        replaceLast = true;\n                    }\n                    this.abortController = undefined;\n                    aiMessage = partialMessage as typeof aiMessage;\n                } else {\n                    this.abortController = undefined;\n                    aiMessage = response.choices[0].message as typeof aiMessage;\n                    await this.appendMessages([aiMessage], false, \"AiMessage\");\n                    this.setStepCount(this.state.stepCount + 1);\n                }\n                if (aiMessage.role == \"assistant\" && aiMessage.tool_calls && aiMessage.tool_calls.length)\n                    toolCalls = aiMessage.tool_calls;\n                return aiMessage;\n            }\n            if (EmodelInvocation) {\n                for (const event of EmodelInvocation) {\n                    const params: Parameters<EventModelInvocation<TMetaData, TGlobalStore, TStore>> = [callAPI, this.context];\n                    const callback = event.callback as EventModelInvocation<TMetaData, TGlobalStore, TStore>;\n                    if (callback.constructor.name == \"AsyncFunction\")\n                        aiMessage = skipEventFallback(await callback(...params), await callAPI());\n                    else\n                        aiMessage = skipEventFallback(callback(...params), await callAPI());\n                }\n            } else\n                await callAPI();\n        } else if (lastMessage?.role == \"assistant\" && lastMessage.tool_calls && lastMessage.tool_calls.length) { // Last message is 'assistant' role without generation required, assign tool calls if any\n            toolCalls = lastMessage.tool_calls;\n        }\n\n        // Handle tool calls if present\n        if (toolCalls.length > 0) {\n            await this.setWaiting();\n            for (const toolCall of toolCalls) {\n                // Check if stop was requested before processing each tool\n                if (this.stopRequested) {\n                    break;\n                }\n\n                // Find tool in options that matches the tool requested by last ai message\n                const tool = this.opts.tools?.find(tool => tool.name == toolCall.function.name);\n                if (!tool)\n                    throw new FragolaError(`Tool ${toolCall.function.name} missing`);\n\n                let paramsParsed: z.SafeParseReturnType<any, any> | undefined;\n                if (tool.schema) {\n                    paramsParsed = (tool.schema as z.Schema).safeParse(JSON.parse(toolCall.function.arguments));\n                    if (!paramsParsed.success) {\n                        //TODO: implement retry system for bad arguments\n                        throw new FragolaError(\"Tool arguments parsing fail\");\n                    }\n                }\n                const toolCallEvents = this.registeredEvents.get(\"toolCall\");\n                const content = await (async () => {\n                    eventProcessing: {\n                        if (!toolCallEvents) {\n                            if (tool.handler == \"dynamic\")\n                                throw new BadUsage(`Tools with dynamic handlers must have at least 1 'toolCall' event that produces a result.`);\n                            break eventProcessing;\n                        }\n                        for (let i = 0; i < toolCallEvents.length; i++) {\n                            const _event = toolCallEvents[i];\n                            const result = isAsyncFunction(_event.callback) ? await _event.callback(paramsParsed?.data, tool as any, this.context)\n                                : _event.callback(paramsParsed?.data, tool as any, this.context);\n                            if (isSkipEvent(result)) {\n                                continue;\n                            }\n                            return result;\n                        }\n                        if (tool.handler == \"dynamic\")\n                            throw new BadUsage(`Tools with dynamic handlers must have at least 1 'toolCall' event that produces a result. (one or more events were found but returned 'skip')`);\n                    }\n                    // Default tool behavior (executed after breaking from eventProcessing)\n                    return isAsyncFunction(tool.handler) ? await tool.handler(paramsParsed?.data, this.context as any) : tool.handler(paramsParsed?.data, this.context as any);\n                })();\n\n                const contentToString = (content: unknown) => {\n                    switch (typeof content) {\n                        case \"string\":\n                            return content;\n                        case \"function\":\n                            return (content as Function).toString();\n                        case \"undefined\":\n                        case \"number\":\n                        case \"boolean\":\n                        case \"bigint\":\n                            return String(content);\n                        default:\n                            return JSON.stringify(content);\n                    }\n                }\n\n                const message: OpenAI.ChatCompletionMessageParam = {\n                    role: \"tool\",\n                    content: contentToString(content),\n                    tool_call_id: toolCall.id\n                }\n                await this.updateConversation((prev) => [...prev, message], \"toolCall\");\n            }\n            await this.setIdle();\n            if (!stop())\n                return await this.recursiveAgent(stepOptions, stop, iter + 1);\n        }\n        await this.setIdle();\n    }\n\n    async userMessage(query: UserMessageQuery): Promise<AgentState> {\n        const { step, ...message } = query;\n        void step;\n        let _message: Omit<ChatCompletionUserMessageParam, \"role\">;\n        if (!this.registeredEvents.handleUserMessage)\n            _message = message;\n        else\n            _message = await this.registeredEvents.handleUserMessage(message);\n        await this.updateConversation((prev) => [...prev, stripUserMessageMeta({ role: \"user\", ..._message })], \"userMessage\");\n        return await this.step(query.step);\n    }\n\n    private async applyEvents<TEventId extends AgentEventId>(eventId: TEventId, _params: applyEventParams<TEventId> | null): Promise<ReturnType<eventIdToCallback<TEventId, TMetaData, TGlobalStore, TStore>>> {\n        const events = this.registeredEvents.get(eventId);\n        type EventDefaultType = EventDefaultCallback<TMetaData, TGlobalStore, TStore>;\n        if (!events)\n            return undefined as ReturnType<eventIdToCallback<TEventId, TMetaData, TGlobalStore, TStore>>;\n        for (let i = 0; i < events.length; i++) {\n            const callback = events[i].callback;\n            const defaultParams: Parameters<EventDefaultType> = [this.createAgentContext()];\n            switch (eventId) {\n                case \"after:stateUpdate\": {\n                    const params: Parameters<EventDefaultType> = defaultParams;\n                    if (isAsyncFunction(callback)) {\n                        return await (callback as EventDefaultType)(...params) as any;\n                    } else {\n                        return (callback as EventDefaultType)(...params) as any;\n                    }\n                }\n                case \"after:conversationUpdate\": {\n                    type callbackType = EventAfterConversationUpdate<TMetaData, TGlobalStore, TStore>;\n                    const params: Parameters<callbackType> = [_params!.reason, ...defaultParams];\n                    if (isAsyncFunction(callback)) {\n                        return await (callback as callbackType)(...params) as any;\n                    } else {\n                        return (callback as callbackType)(...params) as any;\n                    }\n                }\n                default: {\n                    throw new FragolaError(`Internal error: event with name '${eventId}' is unknown`)\n                }\n            }\n        }\n        return undefined as ReturnType<eventIdToCallback<TEventId, TMetaData, TGlobalStore, TStore>>;\n    }\n\n    /**\n     * Register a handler for a given event id.\n     * Returns an unsubscribe function that removes the registered handler.\n     *\n     * @example\n     * // listen to userMessage events\n     * const off = agent.on('userMessage', (message, context) => {\n     *   // inspect or transform the message\n     *   return { ...message, content: message.content.trim() };\n     * });\n     * // later\n     * off();\n     */\n    on<TEventId extends AgentEventId>(eventId: TEventId, callback: eventIdToCallback<TEventId, TMetaData, TGlobalStore, TStore>\n    ) {\n        type EventTargetType = registeredEvent<TEventId, TMetaData, TGlobalStore, TStore>;\n        const events = this.registeredEvents.get(eventId) || [] as EventTargetType[];\n        const id = nanoid();\n        events.push({\n            id,\n            callback: callback\n        });\n        this.registeredEvents.set(eventId, events);\n\n        return () => {\n            let events = this.registeredEvents.get(eventId);\n            if (!events)\n                return;\n            events = events.filter(event => event.id != id);\n            if (!events.length)\n                this.registeredEvents.delete(eventId);\n            else\n                this.registeredEvents.set(eventId, events);\n        }\n    }\n\n    /**\n     * Register a tool call event handler.\n     *\n     * This handler is invoked when the agent needs to execute a tool. Handlers may return a value\n     * that will be used as the tool result.\n     *\n     * @example\n     * // simple tool handler that returns an object as result\n     * agent.onToolCall(async (params, tool, context) => {\n     *   // dynamic tools do not have a handler function, so we skip them\n     *   if (params.handler == \"dynamic\") return skip();\n     *   // do something with params and tool\n     *   try {\n     *      const result = await tool.handler(params);\n     *      return { sucess: true, result }\n     * } catch(e) {\n     *      if (e extends Error)\n     *      return { error: e.message }\n     * }\n     * });\n     */\n    onToolCall<TParams = Record<any, any>>(callback: EventToolCall<TParams, TMetaData, TGlobalStore, TStore>) { return this.on(\"toolCall\", callback) }\n\n    /**\n     * Register a handler that runs after the conversation is updated.\n     *\n     * After-event handlers do not return a value. Use these to persist state, emit metrics or side-effects.\n     *\n     * @example\n     * agent.onAfterConversationUpdate((reason, context) => {\n     *   // persist conversation to a DB or telemetry\n     *   console.log('conversation updated because of', reason);\n     *   context.getStore()?.value.lastSaved = Date.now();\n     * });\n     */\n    onAfterConversationUpdate(callback: EventAfterConversationUpdate<TMetaData, TGlobalStore, TStore>) { return this.on(\"after:conversationUpdate\", callback) }\n\n    /**\n     * Register an AI message event handler.\n     *\n     * Called when an assistant message is generated or streaming. Handlers may return a modified\n     * message which will replace the message in the conversation.\n     *\n     * @example\n     * agent.onAiMessage((message, isPartial, context) => {\n     *   if (!isPartial && message.content.includes('debug')) {\n     *     // modify final assistant message\n     *      message.content += '(edited)';\n     *   }\n     *   return message;\n     * });\n     */\n    onAiMessage(callback: EventAiMessage<TMetaData, TGlobalStore, TStore>) { return this.on(\"aiMessage\", callback) }\n\n    /**\n     * Register a user message event handler.\n     *\n     * Called when a user message is appended to the conversation. Handlers may return a modified\n     * user message which will be used instead of the original.\n     *\n     * @example\n     * agent.onUserMessage((message, context) => {\n     *   // enrich user message with metadata\n     *   return { ...message, content: message.content.trim() };\n     * });\n     */\n    onUserMessage(callback: EventUserMessage<TMetaData, TGlobalStore, TStore>) { return this.on(\"userMessage\", callback) }\n\n    /**\n     * Register a model invocation event handler.\n     *\n     * This handler wraps the model call. It receives a `callAPI` function to perform the request and\n     * can return a modified assistant message. Handlers can also provide a `processChunk` function to\n     * edit streaming chunks before they are applied to the partial assistant message.\n     *\n     * @example\n     * // modify streaming chunks before they are applied\n     * agent.onModelInvocation(async (callAPI, context) => {\n     *   const processChunk: CallAPIProcessChuck = (chunk, partial) => {\n     *     // e.g. redact sensitive tokens or append extra tokens\n     *     chunck.choices[0].delta.content = '(modified)';\n     *     // perform modifications on `modified` here\n     *     return chunck;\n     *   };\n     *   // pass the processor to callAPI; it returns the final assistant message\n     *   const aiMsg = await callAPI(processChunk);\n     *   // post-process the final assistant message if needed\n     *   return { ...aiMsg, content: aiMsg.content + '\\n\\n(checked)' };\n     * });\n     */\n    onModelInvocation(callback: EventModelInvocation<TMetaData, TGlobalStore, TStore>) { return this.on(\"modelInvocation\", callback) }\n\n    /**\n     * Register a handler that runs after the agent state is updated.\n     *\n     * After-state-update handlers do not return a value. Use these for side-effects such as metrics\n     * or asynchronous persistence.\n     *\n     * @example\n     * agent.onAfterStateUpdate((context) => {\n     *   // e.g. emit metrics about step count\n     *   console.log('stepCount', context.state.stepCount);\n     * });\n     */\n    onAfterStateUpdate(callback: AfterStateUpdateCallback<TMetaData, TGlobalStore, TStore>) { return this.on(\"after:stateUpdate\", callback) }\n}\n\nexport type AgentAny = Agent<any, any, any>;"],
  "mappings": "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",
  "names": ["Store", "stripUserMessageMeta", "zodToJsonSchema", "streamChunkToMessage", "isAsyncFunction", "isSkipEvent", "skipEventFallback", "BadUsage", "FragolaError", "MaxStepHitError", "OpenAI", "nanoid", "EventMap", "createStore", "data", "defaultStepOptions", "AGENT_FRIEND", "AgentContext", "_state", "_options", "_store", "_globalStore", "setInstructionsFn", "setOptionsFn", "stopFn", "newState", "newOptions", "instructions", "options", "AgentRawContext", "rawMethods", "Agent", "opts", "globalStore", "openai", "state", "callback", "rawContext", "result", "tool", "messages", "replaceLast", "reason", "prev", "stepOptions", "maxStep", "stepParams", "overrideStepOptions", "by", "rest", "params", "conversation", "i", "msg", "value", "stop", "iter", "lastMessage", "aiMessage", "lastAiMessage", "toolCalls", "toolCall", "message", "EmodelInvocation", "defaultProcessChunck", "chunck", "defaultModelSettings", "callAPI", "processChunck", "modelSettings", "clientOpts", "_processChunck", "_modelSettings", "role", "requestBody", "response", "partialMessage", "_chunck", "updateReason", "partialMessageFinal", "event", "paramsParsed", "toolCallEvents", "content", "eventProcessing", "_event", "query", "step", "_message", "eventId", "_params", "events", "defaultParams", "id"]
}
